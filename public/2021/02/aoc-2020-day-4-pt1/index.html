<!doctype html><html><head><meta charset=utf-8><title>brendan tang</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/style.css></head><body><div class=wrapper><header class=site-header><ol class=site-navigation><li><a title="brendan tang" href=https://brendantang.net/>üêí brendan tang</a></li>‚ñ∏<li><a title=posts href=https://brendantang.net/posts/>ü§î posts</a></li>‚ñ∏<li class=active><a title="AoC 2020 Day 4 Pt1" href=https://brendantang.net/2021/02/aoc-2020-day-4-pt1/>AoC 2020 Day 4...</a></li></ol><ul class=site-navigation><li><a title=tags href=/tags>üè∑</a></li><li><a title=notebook href=/notebook>üìì</a></li><li><a title="my github" href=https://github.com/brendantang>üíª</a></li></ul></header><div id=content><article><h1>AoC 2020 Day 4 Pt1</h1><aside><time>created Thursday, Feb 18, 2021</time><br><code>last commit
<a href=https://github.com/brendantang/brendantang.net/commit/bebc3902644d27f40a514bedf6f0235c142c22e7>bebc390</a>
<time>Apr 24, 2021</time>
Put back language formatting in haskell post</code></aside><blockquote><p>I&rsquo;ve already <a href=https://www.brendantang.net/2021/01/advent-of-code-2020-in-haskell/>mentioned</a> I&rsquo;ve been solving some of the 2020 Advent of Code puzzles as a way to pick up Haskell.
I¬†meant to jot down some notes on my thought process while working on this problem and ended up writing like a whole walkthrough/comparison of the solution in both Ruby and Haskell lol</p><p>Here&rsquo;s the <a href=https://github.com/brendantang/aoc_2020_haskell/tree/main/day4>repository</a> with my answers.</p></blockquote><p>So the <a href=https://adventofcode.com/2020/day/4>problem</a> is basically that we have a big text file full of records consisting of <code>key:value</code> pairs.
Each <code>key</code> is separated from its <code>value</code> by a <code>:</code>, pairs are separated by whitespace, and records (collections of key, value pairs representing passports) are separated by empty lines:</p><pre><code>byr:1983 iyr:2017
pid:796082981 cid:129 eyr:2030
ecl:oth hgt:182cm

iyr:2019
cid:314
eyr:2039 hcl:#cfa07d hgt:171cm ecl:#0180ce byr:2006 pid:8204115568

byr:1991 eyr:2022 hcl:#341e13 iyr:2016 pid:729933757 hgt:167cm ecl:gry

hcl:231d64 cid:124 ecl:gmt eyr:2039
hgt:189in
pid:#9c3ea1

...
</code></pre><p>Part 1 of the problem asks me to find the number of passports with all seven required fields (&ldquo;cid&rdquo; is not required).</p><p>I&rsquo;m finding it really tricky to get out of the imperative mindset!</p><h2 id=imperative-ruby-solution>Imperative (Ruby) solution</h2><p>In ruby I would probably do something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>data <span style=color:#f92672>=</span> <span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>read(<span style=color:#e6db74>&#34;data.txt&#34;</span>)

passport_hashes <span style=color:#f92672>=</span> data<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>)<span style=color:#f92672>.</span>map <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>passport_string<span style=color:#f92672>|</span>
  passport_string<span style=color:#f92672>.</span>split<span style=color:#f92672>.</span>inject({}) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>passport_hash, field_string<span style=color:#f92672>|</span>
    key, val <span style=color:#f92672>=</span> field_string<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;:&#34;</span>)
    passport_hash<span style=color:#f92672>[</span>key<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> val
    passport_hash
  <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>Split the string on empty newlines getting a string of data for each passport, loop through each of those passport strings, split them on whitespace to get strings for each key:value pair, and loop through <em>those</em> strings to construct a hash for the password.</p><p>Finally, to get the count of passports with all seven required fields present, I loop through the list of hashes, incrementing a counter for each passport with the required keys:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#66d9ef>RequiredKeys</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>%w[ byr iyr eyr hgt hcl ecl pid ]</span>

number_of_passports_with_required_fields <span style=color:#f92672>=</span>
  passport_hashes<span style=color:#f92672>.</span>inject(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>count, passport<span style=color:#f92672>|</span>
    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>RequiredKeys</span> <span style=color:#f92672>-</span> passport<span style=color:#f92672>.</span>keys)<span style=color:#f92672>.</span>empty?
  <span style=color:#66d9ef>end</span>

puts number_of_passports_with_required_fields
</code></pre></div><p>In other words, the imperative approach is to describe the steps to go from</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#e6db74>&#34;byr:1983 iyr:2017
</span><span style=color:#e6db74>pid:796082981 cid:129 eyr:2030
</span><span style=color:#e6db74>ecl:oth hgt:182cm
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>iyr:2019
</span><span style=color:#e6db74>cid:314
</span><span style=color:#e6db74>eyr:2039 hcl:#cfa07d hgt:171cm ecl:#0180ce byr:2006 pid:8204115568&#34;</span>
</code></pre></div><p>to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#f92672>[</span>
  <span style=color:#e6db74>&#34;byr:1983 iyr:2017
</span><span style=color:#e6db74>  pid:796082981 cid:129 eyr:2030
</span><span style=color:#e6db74>  ecl:oth hgt:182cm&#34;</span>,
  <span style=color:#e6db74>&#34;iyr:2019
</span><span style=color:#e6db74>  cid:314
</span><span style=color:#e6db74>  eyr:2039 hcl:#cfa07d hgt:171cm ecl:#0180ce byr:2006 pid:8204115568&#34;</span>
<span style=color:#f92672>]</span>
</code></pre></div><p>to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#f92672>[</span>
  <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;byr:1983&#34;</span>, <span style=color:#e6db74>&#34;iyr:2017&#34;</span>, <span style=color:#e6db74>&#34;pid:796082981&#34;</span>, <span style=color:#e6db74>&#34;cid:129&#34;</span>, <span style=color:#e6db74>&#34;eyr:2030&#34;</span>, <span style=color:#e6db74>&#34;ecl:oth&#34;</span>, <span style=color:#e6db74>&#34;hgt:182cm&#34;</span><span style=color:#f92672>]</span>,
  <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;iyr:2019&#34;</span>, <span style=color:#e6db74>&#34;cid:314&#34;</span>, <span style=color:#e6db74>&#34;eyr:2039&#34;</span>, <span style=color:#e6db74>&#34;hcl:#cfa07d&#34;</span>, <span style=color:#e6db74>&#34;hgt:171cm&#34;</span>, <span style=color:#e6db74>&#34;ecl:#0180ce&#34;</span>, <span style=color:#e6db74>&#34;byr:2006&#34;</span>, <span style=color:#e6db74>&#34;pid:8204115568&#34;</span><span style=color:#f92672>]</span>
<span style=color:#f92672>]</span>
</code></pre></div><p>to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#f92672>[</span>
  {<span style=color:#e6db74>&#34;byr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;1983&#34;</span>, <span style=color:#e6db74>&#34;iyr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;2017&#34;</span>, <span style=color:#e6db74>&#34;pid&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;796082981&#34;</span>, <span style=color:#e6db74>&#34;cid&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;129&#34;</span>, <span style=color:#e6db74>&#34;eyr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;2030&#34;</span>, <span style=color:#e6db74>&#34;ecl&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;oth&#34;</span>, <span style=color:#e6db74>&#34;hgt&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;182cm&#34;</span>},
  {<span style=color:#e6db74>&#34;iyr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;2019&#34;</span>, <span style=color:#e6db74>&#34;cid&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;314&#34;</span>, <span style=color:#e6db74>&#34;eyr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;2039&#34;</span>, <span style=color:#e6db74>&#34;hcl&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;#cfa07d&#34;</span>, <span style=color:#e6db74>&#34;hgt&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;171cm&#34;</span>, <span style=color:#e6db74>&#34;ecl&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;#0180ce&#34;</span>, <span style=color:#e6db74>&#34;byr&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;2006&#34;</span>, <span style=color:#e6db74>&#34;pid&#34;</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;8204115568&#34;</span>}
<span style=color:#f92672>]</span>
</code></pre></div><p>Where you can finally loop through each hash comparing its keys to the set of required keys.</p><p>I basically write a bunch of loops, each time pushing the data a little closer to a shape that&rsquo;s easier for me to work with.</p><h2 id=haskell-solution-declarative-i-guess>Haskell solution (declarative I guess?)</h2><p>In some ways my Haskell solution feels like it&rsquo;s approaching the solution from the other end.</p><p>Where in the Ruby solution I started by saying what I have (the string from <code>data.txt</code>) and described the steps to take to get what I want (the count of passports with all required fields),
in the Haskell solution I start by declaring what I want and working backwards from there.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- I start by saying &#34;a passport is a list of fields, where each field is a pair of key, value.&#34;</span>
<span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Passport</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>PassportField</span>]
<span style=color:#66d9ef>type</span> <span style=color:#66d9ef>PassportField</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>String</span>)

<span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
    inputString <span style=color:#f92672>&lt;-</span> readFile <span style=color:#e6db74>&#34;data.txt&#34;</span>

    <span style=color:#75715e>-- Then I say, &#34;let&#39;s assume there&#39;s a function `parsePassports` which takes a string and turns it into a list of Passports.</span>
    <span style=color:#66d9ef>let</span> passports <span style=color:#f92672>=</span> parsePassports inputString

    <span style=color:#75715e>-- If I also have a function `hasRequiredFields` which tests if a Passport has all required fields,</span>
    <span style=color:#75715e>-- then the number of valid passports is the length of the list of Passports that pass that test.</span>
    <span style=color:#66d9ef>let</span> passportCount <span style=color:#f92672>=</span> length <span style=color:#f92672>$</span> filter hasRequiredFields passports 

    print <span style=color:#f92672>$</span> show passportCount
</code></pre></div><p>I start by describing the solution we want (the count of valid passports) and breaking it into smaller solutions‚Äîa way to get a list of passports from a string, and a way to test if a passport is valid.</p><p>From there, I can continue &ldquo;working my way backwards&rdquo; by breaking those problems into smaller ones.
Let&rsquo;s start with testing whether a passport has all the required fields.</p><h3 id=testing-a-passport-for-required-fields>Testing a Passport for required fields</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>hasRequiredFields</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Passport</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
<span style=color:#a6e22e>hasRequiredFields</span> passport <span style=color:#f92672>=</span> null (requiredKeys <span style=color:#f92672>\\</span> keys passport)
</code></pre></div><p><code>(\\)</code> is an operator that evaluates the difference between two lists, such that: <code>[1, 2, 3] \\ [2, 1]</code> is <code>[3]</code>.
So if the list of required keys <code>\\</code> the list of the passport&rsquo;s keys is empty, then we know the passport has all the required keys.</p><p>Now I&rsquo;ve broken the <code>hasRequiredFields</code> test into two smaller problems: how to find the list of <code>requiredKeys</code>, and how to get the list of <code>keys</code> from a passport.</p><h4 id=getting-required-keys>Getting required keys</h4><p>The list of required keys is just a list, so we can define it without breaking it down into any smaller problems:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>requiredKeys</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;byr&#34;</span>,<span style=color:#e6db74>&#34;iyr&#34;</span>,<span style=color:#e6db74>&#34;eyr&#34;</span>,<span style=color:#e6db74>&#34;hgt&#34;</span>,<span style=color:#e6db74>&#34;hcl&#34;</span>,<span style=color:#e6db74>&#34;ecl&#34;</span>,<span style=color:#e6db74>&#34;pid&#34;</span>]
</code></pre></div><h4 id=getting-a-list-of-keys-from-a-passport>Getting a list of keys from a Passport</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>keys</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Passport</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>String</span>]
<span style=color:#a6e22e>keys</span> passport <span style=color:#f92672>=</span> ks 
    <span style=color:#66d9ef>where</span> (ks, <span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> unzip passport
</code></pre></div><p>A Passport is a list of string pairs (<code>[(String,String)]</code>) where the first item of each pair is the key and the other item is the value.
<code>unzip</code> is a function included in the Prelude which takes a list of pairs (<code>[(first thing, second thing)]</code>) and turns it into a pair of lists (<code>([all first things], [all second things])</code>).
So the <code>keys</code> function I wrote just says, &ldquo;give me <code>ks</code>, where <code>ks</code> is the first list (the list of keys) from the pair of lists we get by unzipping passport, and throw the other one (the list of values) away (<code>_</code>).&rdquo;</p><p>With complete definitions for <code>hasRequiredFields</code> and its subproblems <code>keys</code> and <code>requiredKeys</code>, we now have a way to <code>filter</code> a list of Passports to get only those with the required fields.</p><p>All that&rsquo;s left now is to get a list of passwords to filter!</p><h3 id=parsing-a-string-into-a-list-of-passports>Parsing a string into a list of Passports</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>parsePassports</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Passport</span>]
<span style=color:#a6e22e>parsePassports</span> s <span style=color:#f92672>=</span> map parsePassport (splitOnEmptyLine s)
</code></pre></div><p>Again I&rsquo;m optimistically starting at the solution and working my way backward.
To turn the input string from <code>data.txt</code> into a list of Passports, we have 2 subproblems:</p><ul><li>Split the string on empty newlines to get a string for each passport (<code>splitOnEmptyLine</code>)</li><li>Parse a string representing a passport into a <code>Passport</code> (<code>parsePassport</code>).</li></ul><p>If we know how to solve those two subproblems, then all we have to do is <code>map</code> over the list of passport strings we get from <code>splitOnEmptyLine</code>-ing <code>s</code>, and apply <code>parsePassport</code> to each of those strings.</p><h3 id=parsing-a-string-into-a-single-passport>Parsing a string into a single passport</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>parsePassport</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Passport</span>
<span style=color:#a6e22e>parsePassport</span> s <span style=color:#f92672>=</span> map parseField (words s)
</code></pre></div><p>Parsing a string into a <code>Passport</code> (which, remember, is a list of <code>PassportField</code>) breaks down to the subproblems of</p><ul><li>Splitting the string into a list of strings, one for each &ldquo;key:value&rdquo; clause</li><li>Parsing a &ldquo;key:value&rdquo; string into a <code>PassportField</code> (a pair <code>(String,String)</code>).</li></ul><p>The clauses for each field are delimited by a single space or newline character (<code>\n</code>), so the Prelude function <code>words</code> does exactly what we want: <code>words "hcl:#b6652a eyr:2028\nhgt:182cm"</code> evaluates to <code>["hcl:#b6652a", "eyr:2028", "hgt:182cm"]</code>.</p><p>If <code>parseField</code> can turn <code>"hgt:182cm"</code> into <code>("hgt", "182cm")</code>, then we just have to <code>map</code> over the list returned by <code>words</code> to get the list of <code>[("key","value"),("key2","value2")]</code> pairs that satisfies our definition of <code>Passport</code>.</p><h4 id=parsing-a-keyvalue-string-to-a-keyvalue-pair>Parsing a &ldquo;key:value&rdquo; string to a (&ldquo;key&rdquo;,&ldquo;value&rdquo;) pair</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>parseField</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>PassportField</span>
<span style=color:#a6e22e>parseField</span> s <span style=color:#f92672>=</span> (key, value)
    <span style=color:#66d9ef>where</span> 
      (key,<span style=color:#66d9ef>_</span><span style=color:#66d9ef>:</span>value) <span style=color:#f92672>=</span> break (<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;:&#39;</span>) s
</code></pre></div><p><code>break</code> is a Prelude function which splits a list (a String is just a list of Char) into a pair, where the first element is a list of elements from the start of the list up to the first element which does not satisfy some condition‚Äîin our case <code>==':'</code>.</p><p>So <code>break (==':') "mykey:myvalue"</code> evaluates to <code>("mykey", ":myvalue")</code>.
But we don&rsquo;t want that colon, so we assign <code>key</code> and <code>value</code> using pattern matching.</p><p>The <code>:</code> in <code>_:value</code> is a list operator that constructs a list by prepending a single element to another list.</p><p>So if I defined a list like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>myList</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span><span style=color:#66d9ef>:</span>[<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>])
</code></pre></div><p>Then <code>myList</code> would evaluate to <code>[1,2,3,4]</code>.</p><p>Pattern matching comes into play here because I&rsquo;m using the <code>:</code> operator on the left side of my assignment expression. Example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(foo<span style=color:#66d9ef>:</span>bar) <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;h&#39;</span>,<span style=color:#e6db74>&#39;e&#39;</span>,<span style=color:#e6db74>&#39;l&#39;</span>,<span style=color:#e6db74>&#39;l&#39;</span>,<span style=color:#e6db74>&#39;o&#39;</span>]
</code></pre></div><p><code>foo</code> then evaluates to <code>'h'</code>, and <code>bar</code> is <code>['e','l','l','o']</code></p><p>By the same token, when I assign <code>_:value = ":myvalue"</code>, I&rsquo;m saying <code>_ = ':'</code> (which just throws it away), and <code>value = ['m','y','v','a','l','u','e']</code></p><h3 id=splitting-the-input-string-on-empty-newlines>Splitting the input string on empty newlines</h3><p>The last thing left to solve is how to split the input string on empty newlines!
I was sort of surprised to have to write a function to do this.
Maybe I&rsquo;m spoiled by Ruby, where you can pretty much always expect the standard library to have an expressive, built in method for common tasks.
In ruby I could just call <code>split("\n\n")</code> on the string and get the list I want.</p><p>I was also thrown off by the different kinds of strings in Haskell.
The regular <code>String</code> type is just a synonym for <code>[Char]</code>, and I was surprised that the standard Prelude didn&rsquo;t have any built in function to, say, split a <code>String</code> into a list of <code>String</code> delimited by some arbitrary substring (like Ruby&rsquo;s <code>split</code>).</p><p>It took me a while to realize that the data type I would want to use is <code>Data.ByteString.Char8</code> if I want nice built in stuff like <a href=https://hackage.haskell.org/package/bytestring-0.11.1.0/docs/Data-ByteString-Char8.html#g:16><code>breakSubstring</code></a>.
But even that just performs the split once and returns a pair, so I would still have to write a function to apply <code>breakSubstring</code> recursively and build a list.</p><p>Just as good to stick with <code>String</code> and use the Prelude function <code>lines</code> instead:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>splitOnEmptyLine</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>String</span>]
<span style=color:#a6e22e>splitOnEmptyLine</span> string <span style=color:#f92672>=</span> firstElem <span style=color:#66d9ef>:</span> restOfTheElems
    <span style=color:#66d9ef>where</span> firstElem <span style=color:#f92672>=</span> unlines firstItemLines
          (firstItemLines, remainingLines) <span style=color:#f92672>=</span> break null (lines string)
          restOfTheElems
            <span style=color:#f92672>|</span> null remainingLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
            <span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> splitOnEmptyLine <span style=color:#f92672>$</span> unlines <span style=color:#f92672>$</span> tail remainingLines

</code></pre></div><p>Coming from an imperative mindset, I&rsquo;m finding it really hard to explain what&rsquo;s going on here but I&rsquo;ll try!
<code>splitOnEmptyLine</code> is basically saying:</p><ul><li><p><code>splitOnEmptyLine string = firstElem : restOfTheElems</code> means give me a string <code>string</code>, and I&rsquo;ll give you the first item of the list&mldr; and also the rest of the list.</p></li><li><p><code>firstElem = unlines firstItemLines</code> - The first item of the list is the list of strings for the lines representing the first passport, collapsed back into a single string.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>unlines</span> [<span style=color:#e6db74>&#34;pid:796082981 cid:129 eyr:2030&#34;</span>,<span style=color:#e6db74>&#34;ecl:oth hgt:182cm&#34;</span>]
<span style=color:#75715e>-- evaluates to &#34;pid:796082981 cid:129 eyr:2030\necl:oth hgt:182cm&#34;</span>
</code></pre></div></li><li><p><code>(firstItemLines, remainingLines) = break null (lines string)</code> - Here we see that <code>firstItemLines</code> we just used is the first item in the pair you get by <code>break</code>ing <code>(lines string)</code> using <code>null</code>.</p><ul><li><code>lines string</code> splits <code>string</code> into a list of strings, one for each line, so if <code>string</code> looks like this:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#e6db74>&#34;pid:796082981 cid:129 eyr:2030
</span><span style=color:#e6db74>ecl:oth hgt:182cm
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>iyr:2019
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>cid:12&#34;</span>
</code></pre></div><p>then <code>lines string</code> looks like: <code>["pid:796082981 cid:129 eyr:2030","ecl:oth hgt:182cm","","iyr:2019","","cid:12"]</code></p></li><li>Notice empty newlines became empty strings, <code>""</code>.</li><li><code>null</code> checks if a String (or any list) is empty, and <code>break null</code> splits a list into a pair of lists just before the first element for which <code>null</code> is true.<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>break</span> null [<span style=color:#e6db74>&#34;pid:796082981 cid:129 eyr:2030&#34;</span>,<span style=color:#e6db74>&#34;ecl:oth hgt:182cm&#34;</span>,<span style=color:#e6db74>&#34;&#34;</span>,<span style=color:#e6db74>&#34;iyr:2019&#34;</span>,<span style=color:#e6db74>&#34;&#34;</span>,<span style=color:#e6db74>&#34;cid:12&#34;</span>]
<span style=color:#75715e>-- evaluates to ([&#34;pid:796082981 cid:129 eyr:2030&#34;,&#34;ecl:oth hgt:182cm&#34;],[&#34;&#34;,&#34;iyr:2019&#34;,&#34;&#34;,&#34;cid:12&#34;])</span>
</code></pre></div></li></ul></li><li><p>So we know how to get the <code>firstElem</code> of our list, what about the <code>restOfTheElems?</code> Well&mldr;</p><ul><li><code>remainingLines</code> is the other list we got from <code>break null (lines string)</code> - it&rsquo;s a list of the lines after the lines for the first passport.<ul><li>If we discard the leading <code>""</code> with <code>tail</code> and <code>unlines</code> it back into a String, then it looks just like our original input string, but shorter: <code>"iyr:2019\n\ncid:12"</code>.</li><li><code>restOfTheElems</code> needs to be a list of strings, each representing a passport.
And we have a function that takes a string in this format and parses it into just such a list‚Äîit&rsquo;s the function we&rsquo;re writing now!</li></ul></li></ul></li><li><p>That means we can say <code>restOfTheElems = splitOnEmptyLine $ unlines $ tail remainingLines</code></p><ul><li>But eventually we&rsquo;ll parse through the whole input string, and there&rsquo;s nothing to keep our function from continuing to invoke itself, so it will just keep adding empty lists forever.</li><li>So we add a guard to handle the case where <code>remainingLines</code> is empty, meaning we&rsquo;ve parsed all the input. That&rsquo;s how we end up with:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>restOfTheElems</span>
  <span style=color:#f92672>|</span> null remainingLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
  <span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> splitOnEmptyLine <span style=color:#f92672>$</span> unlines <span style=color:#f92672>$</span> tail remainingLines
</code></pre></div></li></ul></li></ul><h2 id=wrap-up>Wrap-up</h2><p>I&rsquo;m sure my code could be more idiomatic, but I feel like the functional/declarative approach is starting to click for me in a way that it hadn&rsquo;t before working on this particular puzzle.</p><p>I really like the way Haskell encourages you to &ldquo;start at the solution&rdquo; and sort of work your way down the tree of subproblems.
I keep thinking it feels less like &ldquo;solving problems&rdquo; and more like &ldquo;naming solutions.&rdquo;
Each solution you name is made up of some combination of other solutions, some of which already have names (like <code>length</code>, <code>filter</code>, <code>unzip</code>, <code>map</code> &mldr;), others you can just name and deal with later (<code>hasRequiredFields</code>, <code>keys</code>&mldr;).</p><p>Some things I&rsquo;m not crazy about / still need to adapt to:</p><ul><li><p>I get why there need to be different <code>String</code> types for the kinds of performance-intensive applications people use Haskell for, but for this kind of thing it felt like a pain.</p></li><li><p>I missed having a really extensive, ergonomic standard library like in Go or Ruby.
I don&rsquo;t know if there was an easier way to <code>splitOnEmptyLine</code> than the function I wrote, but that&rsquo;s kind of the point.
For a task as common as &ldquo;split a string on some substring,&rdquo; should a newcomer to the language have to deal with even the tiny friction of deciding whether to look for an external library or write their own function?
Shouldn&rsquo;t there just be a built in <code>splitOnSubstring</code> function, for <code>String</code> AND <code>ByteString</code>?</p></li><li><p>I think the language almost encourages too much brevity.
I felt like I had to exercise restraint to keep my code wordy enough that I could walk away for ten minutes and come back and have it mean anything to me.
Part of that, of course, is because I&rsquo;m new to the language.
Also, most of the Haskell code I&rsquo;m reading is in libraries where the problems being addressed are abstract enough that <code>x</code> or <code>xs</code> really is the most descriptive variable name, and I&rsquo;m probably tempted to be too brief by mimicking their style.
But I do think there are things about the language itself that nudge you in this direction:</p><p>The way you&rsquo;re encouraged to break big, specific problems into smaller and more general subproblems is a strength, to be sure, but it also introduces a balancing act.
Writing a bunch of increasingly abstract subproblems means you end up with a bunch of functions you can reuse in other situations, but you have to make sure you&rsquo;re making abstractions that strike the right balance of usefulness in other contexts and expressing your intent in the current context.</p><p>Like I could have written <code>splitOnEmptyLine</code> in a way that would be more tightly coupled to the current use case:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>getPassportStrings</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>String</span>]
<span style=color:#a6e22e>getPassportStrings</span> string <span style=color:#f92672>=</span> firstPassport <span style=color:#66d9ef>:</span> restOfThePassports
    <span style=color:#66d9ef>where</span> firstPassport <span style=color:#f92672>=</span> unlines firstPassportLines
          (firstPassportLines, remainingLines) <span style=color:#f92672>=</span> break null (lines string)
          restOfThePassports
            <span style=color:#f92672>|</span> null remainingLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
            <span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> splitOnEmptyLine <span style=color:#f92672>$</span> unlines <span style=color:#f92672>$</span> tail remainingLines
</code></pre></div><p>In a way this is more readable in the context that I&rsquo;m working on, but it obscures the fact that I could use this function anywhere I want to split a string on empty lines!
On the other hand, I could have written a more abstract function like <code>splitOnSubstring</code>, which could be used in more situations, but would also introduce a whole other idea to the program, and maybe distract the reader from the problem at hand.</p><ul><li>One final quibble with the language design: I don&rsquo;t like that there are so many unpronouncable operators. How am I supposed to refer to <code>\\</code> or the <code>(x:xs)</code> list syntax in conversation?</li></ul></li></ul><p>All things considered I must be enjoying Haskell a lot, or I wouldn&rsquo;t have spent so much time writing these notes üßê</p></article><nav class=sidebar><h3>Tags</h3><ul><li><a href=/tags/haskell/>haskell</a></li><li><a href=/tags/aoc2020/>AOC2020</a></li></ul><hr><h3>Adjacent</h3><div><a href=/2021/01/advent-of-code-2020-in-haskell/>‚Üê Advent of Code 2020 in Haskell</a><br>- - -<br></div><div><h3>Related</h3><ul><li><a href=/2021/01/advent-of-code-2020-in-haskell/>Advent of Code 2020 in Haskell</a></li></ul></div></nav></div><footer style=max-width:100%><a href=/><img style=max-width:100% src=/glasses.svg></a></footer></div></body></html>